-- Health Data Storage Basic SQL setup

-- Custom types
create type public.app_role as enum ('admin', 'moderator', 'physician', 'organisation');
create type public.app_permission as enum ('variables.delete', 'measurements.delete');
create type public.user_gender as enum ('MALE', 'FEMALE', 'DIVERSE');

-- USERS
create table public.users (
  id              uuid not null primary key, -- UUID from auth.users
  display_name    text,
  email           text default null,
  email_verified  boolean,
  phone_number    text,
  photo_url       text,
  firstname       text,
  middlename      text,
  lastname        text,
  country_code    text,
  state           text,
  city            text,
  postal_code     text,
  address         text,
  address_2       text,
  phone           text,
  bio             text,
  gender          user_gender not null,
  date_of_birth   text,
  weight_at_signup  text,
  height_at_signup  text,
  blood_type       text,
  body_type        text,
  ethnicity        text,
  skin_type        text,
  lifestyle        text,
  fitness_level    text,
  diet             text
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

  -- VARIABLES
create table public.variables (
  id bigint generated by default as identity primary key,
  string_id varchar(200) DEFAULT NULL,
  slug varchar(200) DEFAULT NULL,
  name varchar(125) NOT NULL,
  abbreviated_name varchar(100) DEFAULT NULL,
  additional_meta_data text,
  canonical_variable_id int DEFAULT NULL,
  created_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  creator_user_id uuid references public.users DEFAULT NULL,
  default_unit_id varchar(125) NOT NULL,
  default_value float DEFAULT NULL,
  deleted_at timestamp NULL DEFAULT NULL,
  deletion_reason varchar(280) DEFAULT NULL,
  description text DEFAULT NULL,
  ranges jsonb DEFAULT NULL,
  reference_urls jsonb DEFAULT NULL,
  parent_id int DEFAULT NULL,
  ref_aact_id int DEFAULT NULL,
  ref_fdc_id int DEFAULT NULL,
  ref_gene_ontology_id int DEFAULT NULL,
  ref_hmdb_id int DEFAULT NULL,
  ref_icd10_id int DEFAULT NULL,
  ref_loinc_id varchar DEFAULT NULL,
  ref_meddra_all_indications_id int DEFAULT NULL,
  ref_meddra_all_side_effects_id int DEFAULT NULL,
  ref_rxnorm_id int DEFAULT NULL,
  ref_snomed_id int DEFAULT NULL,
  ref_uniprot_id int DEFAULT NULL,
  synonyms jsonb DEFAULT NULL,
  updated_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, --  ON UPDATE CURRENT_TIMESTAMP
  tags jsonb DEFAULT NULL,
  variable_category_id int NOT NULL,
  version_first_released varchar(255) DEFAULT NULL,
  version_last_changed varchar(255) DEFAULT NULL,
  unique (string_id, slug, abbreviated_name, name, canonical_variable_id)
  -- UNIQUE KEY variables_string_id_uindex (string_id),
  -- KEY fk_variableDefaultUnit (default_unit_id) USING BTREE,
  -- KEY IDX_cat_unit_public_name (default_unit_id,name,id) USING BTREE,
  -- KEY public_deleted_at_synonyms (deleted_at,synonyms),
  -- CONSTRAINT variable_id_fk FOREIGN KEY (variable_id) REFERENCES variables (id) ON DELETE SET NULL,
  -- CONSTRAINT variables_default_unit_id_fk FOREIGN KEY (default_unit_id) REFERENCES units (id)
);
comment on table public.variables is 'Variables with their metadata for reference in measurement data points';

create table public.measurements (
    id bigint generated by default as identity primary key,
    user_id uuid references public.users not null,
    client_id varchar(80) not null,
    connector_id int null,
    variable_id int not null,
    start_at timestamp not null,
    end_at timestamp not null,
    value float not null,
    unit_id smallint not null,
    original_value float not null,
    original_unit_id smallint not null,
    duration int null,
    note text null,
    latitude float null,
    longitude float null,
    location varchar(255) null,
    created_at timestamp default CURRENT_TIMESTAMP not null,
    updated_at timestamp default CURRENT_TIMESTAMP not null,
    error text null,
    deleted_at timestamp null,
    connection_id int null,
    connector_import_id int null,
    deletion_reason varchar(280) null,
    original_start_at timestamp not null
  	-- constraint measurements_pk
		-- unique (user_id, variable_id, start_at),
	  -- constraint measurements_connections_id_fk
		-- foreign key (connection_id) references connections (id),
	  -- constraint measurements_connector_imports_id_fk
		-- foreign key (connector_import_id) references connector_imports (id),
	  -- constraint measurements_connectors_id_fk
		-- foreign key (connector_id) references connectors (id),
	  -- constraint measurements_original_unit_id_fk
		-- foreign key (original_unit_id) references units (id),
	  -- constraint measurements_unit_id_fk
		-- foreign key (unit_id) references units (id),
	  -- constraint measurements_user_id_fk
		-- foreign key (user_id) references users (id),
	  -- constraint measurements_variables_id_fk
		-- foreign key (variable_id) references variables (id)
);
comment on table public.measurements is 'Measurements are any value that can be recorded like a lab test result, daily steps, a mood rating, or apples eaten.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as
$$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$
language plpgsql security definer;

-- Secure the tables
alter table public.users
  enable row level security;
alter table public.user_roles
  enable row level security;
alter table public.role_permissions
  enable row level security;
alter table public.variables
  enable row level security;
alter table public.measurements
  enable row level security;

create policy "Allow logged-in read access" on public.users
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.users
  for insert with check (auth.uid() = id);
create policy "Allow individual update access" on public.users
  for update using ( auth.uid() = id );
create policy "Allow logged-in read access" on public.variables
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.variables
  for insert with check (auth.uid() = creator_user_id);
create policy "Allow individual delete access" on public.variables
  for delete using (auth.uid() = creator_user_id);
create policy "Allow authorized delete access" on public.variables
  for delete using (authorize('variables.delete', auth.uid()));
  -- Alternative for public access:
-- create policy  "Allow read access for all users" ON "public"."variables"
  -- AS PERMISSIVE FOR SELECT TO public USING (true)
create policy "Allow logged-in read access" on public.measurements
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.measurements
  for insert with check (auth.uid() = user_id);
create policy "Allow individual update access" on public.measurements
  for update using (auth.uid() = user_id);
create policy "Allow individual delete access" on public.measurements
  for delete using (auth.uid() = user_id);
create policy "Allow authorized delete access" on public.measurements
  for delete using (authorize('measurements.delete', auth.uid()));
create policy "Allow individual read access" on public.user_roles
  for select using (auth.uid() = user_id);

-- Send "previous data" on change
alter table public.users
  replica identity full;
alter table public.variables
  replica identity full;
alter table public.measurements
  replica identity full;
  
  -- inserts a row into public.users and assigns roles
create function public.handle_new_user()
returns trigger as
$$
  declare is_admin boolean;
  begin
    insert into public.users (id, username)
    values (new.id, new.email);

    select count(*) = 1 from auth.users into is_admin;

    if position('+supaadmin@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'admin');
    elsif position('+supamod@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'moderator');
    end if;

    return new;
  end;
$$ language plpgsql security definer;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
