-- Health Data Storage Basic SQL setup

-- Custom types
create type public.app_role as enum ('user', 'admin', 'moderator', 'physician', 'organisation');
create type public.app_permission as enum ('variables.delete', 'measurements.delete');
create type public.user_gender as enum ('male', 'female', 'diverse', 'unspecified');

-- USERS
create table public.users (
  id              uuid not null primary key, -- UUID from auth.users
  display_name    text,
  email           text default null,
  email_verified  boolean,
  phone_number    text,
  photo_url       text,
  firstname       text,
  middlename      text,
  lastname        text,
  country_code    text,
  state           text,
  city            text,
  postal_code     text,
  address         text,
  address_2       text,
  phone           text,
  biography       text,
  gender          user_gender not null,
  date_of_birth   text,
  blood_type       text
);
comment on table public.users is 'Profile data for each user.';
comment on column public.users.id is 'References the internal Supabase Auth user.';

create table public.variable_categories
(
    id             smallint generated by default as identity primary key,
    name           varchar(64),
    created_at     timestamp,
    updated_at     timestamp,
    description    varchar(255),
    synonyms       varchar(600),
    string_id      varchar(200),
    slug           varchar(200)
);
comment on table public.variable_categories is 'Categories for the variables.';

  -- VARIABLES
create table public.variables (
  id 		bigint generated by default as identity primary key,
  string_id 	varchar(200) DEFAULT NULL,
  slug 		varchar(200) DEFAULT NULL,
  name 		varchar(125) NOT NULL,
  abbreviated_name 		varchar(100) DEFAULT NULL,
  additional_meta_data 		jsonb DEFAULT NULL,
  canonical_variable_id 	int DEFAULT NULL,
  created_at 			timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  creator_user_id 		uuid references public.users DEFAULT NULL,
  default_unit_id 		varchar(125) NOT NULL,
  default_value 		float DEFAULT NULL,
  description 			text DEFAULT NULL,
  ranges 			jsonb DEFAULT NULL,
  reference_urls 		jsonb DEFAULT NULL,
  parent_id 			int DEFAULT NULL,
  ref_aact_id 			int DEFAULT NULL,
  ref_fdc_id 			int DEFAULT NULL,
  ref_gene_ontology_id 		int DEFAULT NULL,
  ref_hmdb_id 			int DEFAULT NULL,
  ref_icd10_id 			int DEFAULT NULL,
  ref_icd11_id 			int DEFAULT NULL,
  ref_loinc_id 			varchar DEFAULT NULL,
  ref_markerdb_id 		varchar DEFAULT NULL,
  ref_meddra_all_indications_id int DEFAULT NULL,
  ref_meddra_all_side_effects_id int DEFAULT NULL,
  ref_rxnorm_id 		int DEFAULT NULL,
  ref_snomed_id 		int DEFAULT NULL,
  ref_uniprot_id 		int DEFAULT NULL,
  synonyms 			jsonb DEFAULT NULL,
  updated_at 			timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, --  ON UPDATE CURRENT_TIMESTAMP
  tags 				jsonb DEFAULT NULL,
  variable_category_id 		smallint references public.variable_categories NOT NULL,
  version_first_released 	varchar(255) DEFAULT NULL,
  version_last_changed 		varchar(255) DEFAULT NULL,
  unique (string_id, slug, abbreviated_name, name)
  -- UNIQUE KEY variables_string_id_uindex (string_id),
  -- KEY fk_variableDefaultUnit (default_unit_id) USING BTREE,
  -- KEY IDX_cat_unit_public_name (default_unit_id,name,id) USING BTREE,
  -- KEY public_deleted_at_synonyms (deleted_at,synonyms),
  -- CONSTRAINT variable_id_fk FOREIGN KEY (variable_id) REFERENCES variables (id) ON DELETE SET NULL,
  -- CONSTRAINT variables_default_unit_id_fk FOREIGN KEY (default_unit_id) REFERENCES units (id)
);
comment on table public.variables is 'Variables with their metadata for reference in measurement data points';

create table public.measurements (
    id 			bigint generated by default as identity primary key,
    user_id 		uuid references public.users not null,
    variable_id 	integer not null,
    start_at 		timestamp not null,
    end_at 		timestamp not null,
    deleted_at          timestamp,
    value 		float not null,
    note 		text null,
    latitude 		float null,
    longitude 		float null,
    created_at 		timestamp default CURRENT_TIMESTAMP not null,
    updated_at 		timestamp default CURRENT_TIMESTAMP not null,
    connector_id 	integer null,
    connection_id 	integer null,
    connector_import_id integer null
  	-- constraint measurements_pk
		-- unique (user_id, variable_id, start_at),
	  -- constraint measurements_connections_id_fk
		-- foreign key (connection_id) references connections (id),
	  -- constraint measurements_connector_imports_id_fk
		-- foreign key (connector_import_id) references connector_imports (id),
	  -- constraint measurements_connectors_id_fk
		-- foreign key (connector_id) references connectors (id),
	  -- constraint measurements_original_unit_id_fk
		-- foreign key (original_unit_id) references units (id),
	  -- constraint measurements_unit_id_fk
		-- foreign key (unit_id) references units (id),
	  -- constraint measurements_user_id_fk
		-- foreign key (user_id) references users (id),
	  -- constraint measurements_variables_id_fk
		-- foreign key (variable_id) references variables (id)
);
comment on table public.measurements is 'Measurements are any value that can be recorded like a lab test result, daily steps, a mood rating, or apples eaten.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references public.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- authorize with role-based access control (RBAC)
create function public.authorize(
  requested_permission app_permission,
  user_id uuid
)
returns boolean as
$$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$
language plpgsql security definer;

-- Secure the tables
alter table public.users
  enable row level security;
alter table public.user_roles
  enable row level security;
alter table public.role_permissions
  enable row level security;
alter table public.variables
  enable row level security;
alter table public.measurements
  enable row level security;

create policy "Allow logged-in read access" on public.users
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.users
  for insert with check (auth.uid() = id);
create policy "Allow individual update access" on public.users
  for update using ( auth.uid() = id );
create policy "Allow logged-in read access" on public.variables
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.variables
  for insert with check (auth.uid() = creator_user_id);
create policy "Allow individual delete access" on public.variables
  for delete using (auth.uid() = creator_user_id);
create policy "Allow authorized delete access" on public.variables
  for delete using (authorize('variables.delete', auth.uid()));
  -- Alternative for public access:
-- create policy  "Allow read access for all users" ON "public"."variables"
  -- AS PERMISSIVE FOR SELECT TO public USING (true)
create policy "Allow logged-in read access" on public.measurements
  for select using (auth.role() = 'authenticated');
create policy "Allow individual insert access" on public.measurements
  for insert with check (auth.uid() = user_id);
create policy "Allow individual update access" on public.measurements
  for update using (auth.uid() = user_id);
create policy "Allow individual delete access" on public.measurements
  for delete using (auth.uid() = user_id);
create policy "Allow authorized delete access" on public.measurements
  for delete using (authorize('measurements.delete', auth.uid()));
create policy "Allow individual read access" on public.user_roles
  for select using (auth.uid() = user_id);

-- Send "previous data" on change
alter table public.users
  replica identity full;
alter table public.variables
  replica identity full;
alter table public.measurements
  replica identity full;
  
  -- inserts a row into public.users and assigns roles
create function public.handle_new_user()
returns trigger as
$$
  declare is_admin boolean;
  begin
    insert into public.users (id, username)
    values (new.id, new.email);

    select count(*) = 1 from auth.users into is_admin;

    if position('+supaadmin@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'admin');
    elsif position('+supamod@' in new.email) > 0 then
      insert into public.user_roles (user_id, role) values (new.id, 'moderator');
    end if;

    return new;
  end;
$$ language plpgsql security definer;

-- trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
